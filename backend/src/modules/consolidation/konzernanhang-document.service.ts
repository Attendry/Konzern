import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { SupabaseService } from '../supabase/supabase.service';
import { SupabaseErrorHandler } from '../../common/supabase-error.util';
import { SupabaseMapper } from '../../common/supabase-mapper.util';
import { ConsolidatedNotesService, ConsolidatedNotes } from './consolidated-notes.service';

// Disclosure types for Konzernanhang sections
export enum DisclosureType {
  CONSOLIDATION_SCOPE = 'consolidation_scope',
  CONSOLIDATION_METHODS = 'consolidation_methods',
  ACCOUNTING_POLICIES = 'accounting_policies',
  GOODWILL = 'goodwill',
  MINORITY_INTERESTS = 'minority_interests',
  INTERCOMPANY_TRANSACTIONS = 'intercompany_transactions',
  CURRENCY_TRANSLATION = 'currency_translation',
  DEFERRED_TAXES = 'deferred_taxes',
  CONTINGENT_LIABILITIES = 'contingent_liabilities',
  FINANCIAL_INSTRUMENTS = 'financial_instruments',
  EMPLOYEES = 'employees',
  BOARD_COMPENSATION = 'board_compensation',
  SIGNIFICANT_EVENTS = 'significant_events',
  SUBSEQUENT_EVENTS = 'subsequent_events',
  RELATED_PARTIES = 'related_parties',
  SEGMENT_REPORTING = 'segment_reporting',
  RESEARCH_DEVELOPMENT = 'research_development',
  OTHER_MANDATORY = 'other_mandatory',
  VOLUNTARY = 'voluntary',
}

// Section status
export enum NoteSectionStatus {
  DRAFT = 'draft',
  REVIEW_PENDING = 'review_pending',
  REVIEWED = 'reviewed',
  FINALIZED = 'finalized',
  SUPERSEDED = 'superseded',
}

// Konzernanhang document interface
export interface KonzernanhangDocument {
  id: string;
  financialStatementId: string;
  version: number;
  isCurrent: boolean;
  fiscalYear: number;
  periodStart: Date;
  periodEnd: Date;
  documentTitle: string;
  status: NoteSectionStatus;
  totalSections: number;
  completedSections: number;
  generatedAt: Date;
  generatedByUserId: string | null;
  generatedByName: string | null;
  reviewedByUserId: string | null;
  reviewedByName: string | null;
  reviewedAt: Date | null;
  reviewNotes: string | null;
  approvedByUserId: string | null;
  approvedByName: string | null;
  approvedAt: Date | null;
  approvalNotes: string | null;
  createdAt: Date;
  updatedAt: Date;
}

// Section interface
export interface KonzernanhangSection {
  id: string;
  documentId: string;
  disclosureType: DisclosureType;
  sectionNumber: string;
  sectionTitle: string;
  hgbSection: string | null;
  isMandatory: boolean;
  contentText: string | null;
  contentJson: any;
  contentHtml: string | null;
  isAutoGenerated: boolean;
  autoGenerationSource: string | null;
  manualOverride: boolean;
  status: NoteSectionStatus;
  hasChangesFromPriorYear: boolean;
  priorYearComparison: string | null;
  displayOrder: number;
  preparedByUserId: string | null;
  preparedByName: string | null;
  preparedAt: Date;
  reviewedByUserId: string | null;
  reviewedByName: string | null;
  reviewedAt: Date | null;
  reviewNotes: string | null;
  createdAt: Date;
  updatedAt: Date;
}

// Export record interface
export interface KonzernanhangExport {
  id: string;
  documentId: string;
  exportFormat: string;
  fileName: string;
  fileSize: number | null;
  filePath: string | null;
  contentHash: string | null;
  exportedByUserId: string | null;
  exportedByName: string | null;
  exportedAt: Date;
  exportPurpose: string | null;
  recipient: string | null;
  downloadCount: number;
  lastDownloadedAt: Date | null;
}

// Template interface
export interface KonzernanhangTemplate {
  id: string;
  disclosureType: DisclosureType;
  templateName: string;
  templateDescription: string | null;
  contentTemplate: string;
  placeholderSchema: any;
  hgbSection: string | null;
  isDefault: boolean;
  usageCount: number;
  isSystemTemplate: boolean;
}

// DTOs
export interface CreateDocumentDto {
  financialStatementId: string;
  documentTitle?: string;
  generatedByUserId?: string;
  generatedByName?: string;
}

export interface CreateSectionDto {
  documentId: string;
  disclosureType: DisclosureType;
  sectionNumber?: string;
  sectionTitle: string;
  hgbSection?: string;
  isMandatory?: boolean;
  contentText?: string;
  contentJson?: any;
  contentHtml?: string;
  isAutoGenerated?: boolean;
  autoGenerationSource?: string;
  displayOrder?: number;
  preparedByUserId?: string;
  preparedByName?: string;
}

export interface UpdateSectionDto {
  sectionTitle?: string;
  contentText?: string;
  contentJson?: any;
  contentHtml?: string;
  manualOverride?: boolean;
  status?: NoteSectionStatus;
  reviewedByUserId?: string;
  reviewedByName?: string;
  reviewNotes?: string;
}

@Injectable()
export class KonzernanhangDocumentService {
  constructor(
    private supabaseService: SupabaseService,
    private consolidatedNotesService: ConsolidatedNotesService,
  ) {}

  private get supabase() {
    return this.supabaseService.getClient();
  }

  // ==========================================
  // DOCUMENT MANAGEMENT
  // ==========================================

  /**
   * Create a new Konzernanhang document for a financial statement
   */
  async createDocument(dto: CreateDocumentDto): Promise<KonzernanhangDocument> {
    // Get financial statement details
    const { data: fs, error: fsError } = await this.supabase
      .from('financial_statements')
      .select('*')
      .eq('id', dto.financialStatementId)
      .single();

    if (fsError || !fs) {
      throw new NotFoundException(`Financial Statement mit ID ${dto.financialStatementId} nicht gefunden`);
    }

    // Check if document already exists
    const { data: existingDocs } = await this.supabase
      .from('konzernanhang_documents')
      .select('version')
      .eq('financial_statement_id', dto.financialStatementId)
      .eq('is_current', true);

    let version = 1;
    if (existingDocs && existingDocs.length > 0) {
      // Mark existing as not current and increment version
      const maxVersion = Math.max(...existingDocs.map((d: any) => d.version));
      version = maxVersion + 1;

      await this.supabase
        .from('konzernanhang_documents')
        .update({ is_current: false })
        .eq('financial_statement_id', dto.financialStatementId)
        .eq('is_current', true);
    }

    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .insert({
        financial_statement_id: dto.financialStatementId,
        version,
        is_current: true,
        fiscal_year: fs.fiscal_year,
        period_start: fs.period_start,
        period_end: fs.period_end,
        document_title: dto.documentTitle || `Konzernanhang ${fs.fiscal_year}`,
        status: 'draft',
        total_sections: 0,
        completed_sections: 0,
        generated_by_user_id: dto.generatedByUserId,
        generated_by_name: dto.generatedByName,
        generated_at: SupabaseMapper.getCurrentTimestamp(),
        created_at: SupabaseMapper.getCurrentTimestamp(),
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'create');
    }

    return this.mapToDocument(data);
  }

  /**
   * Get document by ID
   */
  async getDocumentById(id: string): Promise<KonzernanhangDocument | null> {
    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'fetch');
    }

    return this.mapToDocument(data);
  }

  /**
   * Get current document for a financial statement
   */
  async getCurrentDocument(financialStatementId: string): Promise<KonzernanhangDocument | null> {
    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .select('*')
      .eq('financial_statement_id', financialStatementId)
      .eq('is_current', true)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null;
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'fetch');
    }

    return this.mapToDocument(data);
  }

  /**
   * Update document status
   */
  async updateDocumentStatus(id: string, status: NoteSectionStatus): Promise<KonzernanhangDocument> {
    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .update({
        status,
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'update');
    }

    return this.mapToDocument(data);
  }

  /**
   * Review document
   */
  async reviewDocument(
    id: string,
    reviewedByUserId: string,
    reviewedByName: string,
    reviewNotes?: string,
  ): Promise<KonzernanhangDocument> {
    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .update({
        status: 'reviewed',
        reviewed_by_user_id: reviewedByUserId,
        reviewed_by_name: reviewedByName,
        reviewed_at: SupabaseMapper.getCurrentTimestamp(),
        review_notes: reviewNotes,
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'review');
    }

    return this.mapToDocument(data);
  }

  /**
   * Approve document (finalize)
   */
  async approveDocument(
    id: string,
    approvedByUserId: string,
    approvedByName: string,
    approvalNotes?: string,
  ): Promise<KonzernanhangDocument> {
    const { data, error } = await this.supabase
      .from('konzernanhang_documents')
      .update({
        status: 'finalized',
        approved_by_user_id: approvedByUserId,
        approved_by_name: approvedByName,
        approved_at: SupabaseMapper.getCurrentTimestamp(),
        approval_notes: approvalNotes,
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Document', 'approve');
    }

    return this.mapToDocument(data);
  }

  // ==========================================
  // SECTION MANAGEMENT
  // ==========================================

  /**
   * Create a new section
   */
  async createSection(dto: CreateSectionDto): Promise<KonzernanhangSection> {
    const { data, error } = await this.supabase
      .from('konzernanhang_sections')
      .insert({
        document_id: dto.documentId,
        disclosure_type: dto.disclosureType,
        section_number: dto.sectionNumber,
        section_title: dto.sectionTitle,
        hgb_section: dto.hgbSection,
        is_mandatory: dto.isMandatory ?? true,
        content_text: dto.contentText,
        content_json: dto.contentJson,
        content_html: dto.contentHtml,
        is_auto_generated: dto.isAutoGenerated ?? false,
        auto_generation_source: dto.autoGenerationSource,
        display_order: dto.displayOrder ?? 0,
        prepared_by_user_id: dto.preparedByUserId,
        prepared_by_name: dto.preparedByName,
        prepared_at: SupabaseMapper.getCurrentTimestamp(),
        status: 'draft',
        created_at: SupabaseMapper.getCurrentTimestamp(),
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Section', 'create');
    }

    // Update section count in document
    await this.updateSectionCounts(dto.documentId);

    return this.mapToSection(data);
  }

  /**
   * Get all sections for a document
   */
  async getSections(documentId: string): Promise<KonzernanhangSection[]> {
    const { data, error } = await this.supabase
      .from('konzernanhang_sections')
      .select('*')
      .eq('document_id', documentId)
      .order('display_order', { ascending: true });

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Sections', 'fetch');
    }

    return (data || []).map(this.mapToSection);
  }

  /**
   * Update a section
   */
  async updateSection(id: string, dto: UpdateSectionDto): Promise<KonzernanhangSection> {
    const updateData: Record<string, any> = {
      updated_at: SupabaseMapper.getCurrentTimestamp(),
    };

    if (dto.sectionTitle !== undefined) updateData.section_title = dto.sectionTitle;
    if (dto.contentText !== undefined) updateData.content_text = dto.contentText;
    if (dto.contentJson !== undefined) updateData.content_json = dto.contentJson;
    if (dto.contentHtml !== undefined) updateData.content_html = dto.contentHtml;
    if (dto.manualOverride !== undefined) updateData.manual_override = dto.manualOverride;
    if (dto.status !== undefined) updateData.status = dto.status;

    if (dto.reviewedByUserId !== undefined) {
      updateData.reviewed_by_user_id = dto.reviewedByUserId;
      updateData.reviewed_by_name = dto.reviewedByName;
      updateData.reviewed_at = SupabaseMapper.getCurrentTimestamp();
      updateData.review_notes = dto.reviewNotes;
    }

    const { data, error } = await this.supabase
      .from('konzernanhang_sections')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Section', 'update');
    }

    // Update section counts
    const section = this.mapToSection(data);
    await this.updateSectionCounts(section.documentId);

    return section;
  }

  /**
   * Delete a section
   */
  async deleteSection(id: string): Promise<void> {
    // Get document ID first
    const { data: section } = await this.supabase
      .from('konzernanhang_sections')
      .select('document_id')
      .eq('id', id)
      .single();

    const { error } = await this.supabase
      .from('konzernanhang_sections')
      .delete()
      .eq('id', id);

    if (error) {
      SupabaseErrorHandler.handle(error, 'Konzernanhang Section', 'delete');
    }

    if (section) {
      await this.updateSectionCounts(section.document_id);
    }
  }

  // ==========================================
  // AUTO-GENERATION
  // ==========================================

  /**
   * Generate all sections automatically from existing consolidation data
   */
  async generateAllSections(documentId: string): Promise<KonzernanhangSection[]> {
    // Get document
    const document = await this.getDocumentById(documentId);
    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    // Get consolidated notes data
    const notes = await this.consolidatedNotesService.generateConsolidatedNotes(
      document.financialStatementId,
    );

    const sections: KonzernanhangSection[] = [];
    let displayOrder = 1;

    // 1. Consolidation Methods
    const methodsSection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.CONSOLIDATION_METHODS,
      sectionNumber: '1',
      sectionTitle: 'Konsolidierungsgrundsätze',
      hgbSection: '§ 313 Abs. 1 Nr. 1 HGB',
      contentText: this.generateConsolidationMethodsText(notes),
      contentJson: notes.consolidationMethods,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(methodsSection);

    // 2. Consolidation Scope
    const scopeSection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.CONSOLIDATION_SCOPE,
      sectionNumber: '2',
      sectionTitle: 'Konsolidierungskreis',
      hgbSection: '§ 313 Abs. 2 Nr. 1-3 HGB',
      contentText: this.generateConsolidationScopeText(notes),
      contentJson: notes.consolidationScope,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(scopeSection);

    // 3. Goodwill
    const goodwillSection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.GOODWILL,
      sectionNumber: '3',
      sectionTitle: 'Geschäfts- oder Firmenwert',
      hgbSection: '§ 313 Abs. 1 Nr. 3 HGB',
      contentText: this.generateGoodwillText(notes),
      contentJson: notes.goodwillBreakdown,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(goodwillSection);

    // 4. Minority Interests
    const minoritySection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.MINORITY_INTERESTS,
      sectionNumber: '4',
      sectionTitle: 'Anteile anderer Gesellschafter',
      hgbSection: '§ 307 HGB',
      contentText: this.generateMinorityInterestsText(notes),
      contentJson: notes.minorityInterestsBreakdown,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(minoritySection);

    // 5. Intercompany Transactions
    const icSection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.INTERCOMPANY_TRANSACTIONS,
      sectionNumber: '5',
      sectionTitle: 'Zwischengesellschaftsgeschäfte',
      hgbSection: '§ 313 Abs. 2 Nr. 5 HGB',
      contentText: this.generateIntercompanyText(notes),
      contentJson: notes.intercompanyTransactions,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(icSection);

    // 6. Accounting Policies
    const policiesSection = await this.createSection({
      documentId,
      disclosureType: DisclosureType.ACCOUNTING_POLICIES,
      sectionNumber: '6',
      sectionTitle: 'Bilanzierungs- und Bewertungsmethoden',
      hgbSection: '§ 313 Abs. 1 Nr. 2 HGB',
      contentText: this.generateAccountingPoliciesText(notes),
      contentJson: notes.accountingPolicies,
      isAutoGenerated: true,
      autoGenerationSource: 'ConsolidatedNotesService',
      displayOrder: displayOrder++,
    });
    sections.push(policiesSection);

    // 7. Related Parties
    if (notes.relatedPartyTransactions.length > 0) {
      const relatedSection = await this.createSection({
        documentId,
        disclosureType: DisclosureType.RELATED_PARTIES,
        sectionNumber: '7',
        sectionTitle: 'Geschäfte mit nahestehenden Unternehmen und Personen',
        hgbSection: '§ 314 Abs. 1 Nr. 13 HGB',
        contentText: this.generateRelatedPartiesText(notes),
        contentJson: notes.relatedPartyTransactions,
        isAutoGenerated: true,
        autoGenerationSource: 'ConsolidatedNotesService',
        displayOrder: displayOrder++,
      });
      sections.push(relatedSection);
    }

    // 8. Significant Events
    if (notes.significantEvents.length > 0) {
      const eventsSection = await this.createSection({
        documentId,
        disclosureType: DisclosureType.SIGNIFICANT_EVENTS,
        sectionNumber: displayOrder.toString(),
        sectionTitle: 'Wesentliche Ereignisse',
        hgbSection: '§ 314 Abs. 1 Nr. 25 HGB',
        contentText: notes.significantEvents.map((e, i) => `${i + 1}. ${e}`).join('\n'),
        contentJson: notes.significantEvents,
        isAutoGenerated: true,
        autoGenerationSource: 'ConsolidatedNotesService',
        displayOrder: displayOrder++,
      });
      sections.push(eventsSection);
    }

    return sections;
  }

  // ==========================================
  // TEXT GENERATION HELPERS
  // ==========================================

  private generateConsolidationMethodsText(notes: ConsolidatedNotes): string {
    let text = 'Der Konzernabschluss wird nach den Vorschriften des Handelsgesetzbuches (HGB) aufgestellt.\n\n';

    for (const method of notes.consolidationMethods) {
      text += `${method.description}\n\n`;
      text += `HGB-Referenz: ${method.hgbReference}\n\n`;
    }

    return text;
  }

  private generateConsolidationScopeText(notes: ConsolidatedNotes): string {
    const scope = notes.consolidationScope;
    let text = `In den Konzernabschluss wurden neben dem Mutterunternehmen ${scope.parentCompany.name} `;
    text += `insgesamt ${scope.subsidiaries.length} Tochterunternehmen einbezogen.\n\n`;

    text += `Anzahl konsolidierter Unternehmen: ${scope.consolidatedCompanies}\n`;
    text += `Anzahl ausgeschlossener Unternehmen: ${scope.excludedCompanies}\n\n`;

    text += 'Tochtergesellschaften:\n';
    for (const sub of scope.subsidiaries) {
      text += `- ${sub.name} (Beteiligung: ${sub.participationPercentage.toFixed(2)}%)\n`;
      if (sub.exclusionReason) {
        text += `  Ausgeschlossen: ${sub.exclusionReason}\n`;
      }
    }

    return text;
  }

  private generateGoodwillText(notes: ConsolidatedNotes): string {
    const goodwill = notes.goodwillBreakdown;
    let text = 'Die im Rahmen der Erstkonsolidierung entstandenen Unterschiedsbeträge ';
    text += `belaufen sich auf insgesamt ${this.formatCurrency(goodwill.total)}.\n\n`;

    if (goodwill.breakdown.length > 0) {
      text += 'Aufschlüsselung nach Tochtergesellschaften:\n';
      for (const item of goodwill.breakdown) {
        text += `- ${item.subsidiaryCompanyName}: Firmenwert ${this.formatCurrency(item.goodwill)}`;
        if (item.negativeGoodwill > 0) {
          text += `, passivischer Unterschiedsbetrag ${this.formatCurrency(item.negativeGoodwill)}`;
        }
        text += '\n';
      }
    }

    text += '\nDer Firmenwert wird gemäß § 309 Abs. 1 HGB planmäßig über die voraussichtliche Nutzungsdauer abgeschrieben.';

    return text;
  }

  private generateMinorityInterestsText(notes: ConsolidatedNotes): string {
    const minority = notes.minorityInterestsBreakdown;
    let text = 'Die Anteile anderer Gesellschafter am Eigenkapital und am Jahresergebnis ';
    text += `der einbezogenen Tochterunternehmen belaufen sich auf insgesamt ${this.formatCurrency(minority.total)}.\n\n`;

    if (minority.breakdown.length > 0) {
      text += 'Aufschlüsselung nach Tochtergesellschaften:\n';
      for (const item of minority.breakdown) {
        text += `- ${item.subsidiaryCompanyName}: Minderheitsanteil ${item.minorityPercentage.toFixed(2)}%, `;
        text += `Eigenkapital ${this.formatCurrency(item.minorityEquity)}\n`;
      }
    }

    return text;
  }

  private generateIntercompanyText(notes: ConsolidatedNotes): string {
    const transactions = notes.intercompanyTransactions;
    
    if (transactions.length === 0) {
      return 'Im Berichtszeitraum wurden keine wesentlichen Zwischengesellschaftsgeschäfte durchgeführt.';
    }

    let text = 'Im Rahmen der Konsolidierung wurden folgende Zwischengesellschaftsgeschäfte eliminiert:\n\n';

    for (const tx of transactions) {
      text += `${tx.description}:\n`;
      text += `- Gesamtbetrag: ${this.formatCurrency(tx.totalAmount)}\n`;
      text += `- Eliminierter Betrag: ${this.formatCurrency(tx.eliminatedAmount)}\n\n`;
    }

    return text;
  }

  private generateAccountingPoliciesText(notes: ConsolidatedNotes): string {
    const policies = notes.accountingPolicies;
    let text = `Konsolidierungsmethode: ${policies.consolidationMethod}\n`;
    text += `Konzernwährung: ${policies.currency}\n`;
    text += `Geschäftsjahresende: ${policies.fiscalYearEnd}\n\n`;

    text += 'Bewertungsmethoden:\n';
    for (const method of policies.valuationMethods) {
      text += `- ${method}\n`;
    }

    return text;
  }

  private generateRelatedPartiesText(notes: ConsolidatedNotes): string {
    const transactions = notes.relatedPartyTransactions;

    if (transactions.length === 0) {
      return 'Im Berichtszeitraum wurden keine meldepflichtigen Geschäfte mit nahestehenden Unternehmen und Personen durchgeführt.';
    }

    let text = 'Folgende Geschäfte wurden mit nahestehenden Unternehmen und Personen durchgeführt:\n\n';

    for (const tx of transactions) {
      text += `- ${tx.relatedParty} (${tx.relationship}): ${tx.transactionType}, ${this.formatCurrency(tx.amount)}\n`;
    }

    return text;
  }

  private formatCurrency(value: number): string {
    return new Intl.NumberFormat('de-DE', {
      style: 'currency',
      currency: 'EUR',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  }

  // ==========================================
  // HELPER METHODS
  // ==========================================

  private async updateSectionCounts(documentId: string): Promise<void> {
    const { data } = await this.supabase
      .from('konzernanhang_sections')
      .select('status')
      .eq('document_id', documentId);

    const total = (data || []).length;
    const completed = (data || []).filter((s: any) => 
      s.status === 'reviewed' || s.status === 'finalized'
    ).length;

    await this.supabase
      .from('konzernanhang_documents')
      .update({
        total_sections: total,
        completed_sections: completed,
        updated_at: SupabaseMapper.getCurrentTimestamp(),
      })
      .eq('id', documentId);
  }

  private mapToDocument(data: any): KonzernanhangDocument {
    return {
      id: data.id,
      financialStatementId: data.financial_statement_id,
      version: data.version,
      isCurrent: data.is_current,
      fiscalYear: data.fiscal_year,
      periodStart: new Date(data.period_start),
      periodEnd: new Date(data.period_end),
      documentTitle: data.document_title,
      status: data.status,
      totalSections: data.total_sections,
      completedSections: data.completed_sections,
      generatedAt: new Date(data.generated_at),
      generatedByUserId: data.generated_by_user_id,
      generatedByName: data.generated_by_name,
      reviewedByUserId: data.reviewed_by_user_id,
      reviewedByName: data.reviewed_by_name,
      reviewedAt: data.reviewed_at ? new Date(data.reviewed_at) : null,
      reviewNotes: data.review_notes,
      approvedByUserId: data.approved_by_user_id,
      approvedByName: data.approved_by_name,
      approvedAt: data.approved_at ? new Date(data.approved_at) : null,
      approvalNotes: data.approval_notes,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }

  private mapToSection(data: any): KonzernanhangSection {
    return {
      id: data.id,
      documentId: data.document_id,
      disclosureType: data.disclosure_type,
      sectionNumber: data.section_number,
      sectionTitle: data.section_title,
      hgbSection: data.hgb_section,
      isMandatory: data.is_mandatory,
      contentText: data.content_text,
      contentJson: data.content_json,
      contentHtml: data.content_html,
      isAutoGenerated: data.is_auto_generated,
      autoGenerationSource: data.auto_generation_source,
      manualOverride: data.manual_override,
      status: data.status,
      hasChangesFromPriorYear: data.has_changes_from_prior_year,
      priorYearComparison: data.prior_year_comparison,
      displayOrder: data.display_order,
      preparedByUserId: data.prepared_by_user_id,
      preparedByName: data.prepared_by_name,
      preparedAt: new Date(data.prepared_at),
      reviewedByUserId: data.reviewed_by_user_id,
      reviewedByName: data.reviewed_by_name,
      reviewedAt: data.reviewed_at ? new Date(data.reviewed_at) : null,
      reviewNotes: data.review_notes,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }
}
