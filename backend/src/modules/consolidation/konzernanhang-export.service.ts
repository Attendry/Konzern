import { Injectable, NotFoundException } from '@nestjs/common';
import { SupabaseService } from '../supabase/supabase.service';
import { SupabaseErrorHandler } from '../../common/supabase-error.util';
import { SupabaseMapper } from '../../common/supabase-mapper.util';
import { 
  KonzernanhangDocumentService, 
  KonzernanhangDocument, 
  KonzernanhangSection 
} from './konzernanhang-document.service';
import * as crypto from 'crypto';

// Export format types
export enum ExportFormat {
  JSON = 'json',
  TEXT = 'text',
  MARKDOWN = 'markdown',
  HTML = 'html',
  PDF = 'pdf',
  WORD_DOCX = 'word_docx',
  XBRL = 'xbrl',
}

// Export result interface
export interface ExportResult {
  format: ExportFormat;
  content: string | Buffer;
  contentType: string;
  fileName: string;
  fileSize: number;
  contentHash: string;
}

// Export metadata for tracking
export interface ExportMetadata {
  id: string;
  documentId: string;
  format: ExportFormat;
  fileName: string;
  fileSize: number;
  contentHash: string;
  exportedByUserId: string | null;
  exportedByName: string | null;
  exportedAt: Date;
  exportPurpose: string | null;
  recipient: string | null;
}

@Injectable()
export class KonzernanhangExportService {
  constructor(
    private supabaseService: SupabaseService,
    private dokumentService: KonzernanhangDocumentService,
  ) {}

  private get supabase() {
    return this.supabaseService.getClient();
  }

  /**
   * Export Konzernanhang document in specified format
   */
  async exportDocument(
    documentId: string,
    format: ExportFormat,
    options?: {
      exportedByUserId?: string;
      exportedByName?: string;
      exportPurpose?: string;
      recipient?: string;
    },
  ): Promise<ExportResult> {
    // Get document and sections
    const document = await this.dokumentService.getDocumentById(documentId);
    if (!document) {
      throw new NotFoundException(`Document with ID ${documentId} not found`);
    }

    const sections = await this.dokumentService.getSections(documentId);

    // Generate export content
    let result: ExportResult;
    
    switch (format) {
      case ExportFormat.JSON:
        result = this.exportAsJson(document, sections);
        break;
      case ExportFormat.TEXT:
        result = this.exportAsText(document, sections);
        break;
      case ExportFormat.MARKDOWN:
        result = this.exportAsMarkdown(document, sections);
        break;
      case ExportFormat.HTML:
        result = this.exportAsHtml(document, sections);
        break;
      default:
        result = this.exportAsJson(document, sections);
    }

    // Record export in database
    await this.recordExport(documentId, result, options);

    // Update last export info in document
    await this.supabase
      .from('konzernanhang_documents')
      .update({
        last_exported_at: SupabaseMapper.getCurrentTimestamp(),
        last_export_format: format,
      })
      .eq('id', documentId);

    return result;
  }

  /**
   * Export as JSON
   */
  private exportAsJson(
    document: KonzernanhangDocument, 
    sections: KonzernanhangSection[],
  ): ExportResult {
    const exportData = {
      document: {
        id: document.id,
        fiscalYear: document.fiscalYear,
        periodStart: document.periodStart.toISOString().split('T')[0],
        periodEnd: document.periodEnd.toISOString().split('T')[0],
        title: document.documentTitle,
        version: document.version,
        status: document.status,
        generatedAt: document.generatedAt.toISOString(),
        reviewedAt: document.reviewedAt?.toISOString(),
        approvedAt: document.approvedAt?.toISOString(),
      },
      sections: sections.map((s) => ({
        sectionNumber: s.sectionNumber,
        title: s.sectionTitle,
        disclosureType: s.disclosureType,
        hgbSection: s.hgbSection,
        isMandatory: s.isMandatory,
        content: s.contentText,
        data: s.contentJson,
        status: s.status,
        isAutoGenerated: s.isAutoGenerated,
      })),
      metadata: {
        exportedAt: new Date().toISOString(),
        totalSections: sections.length,
        hgbReferences: this.getHgbReferences(),
      },
    };

    const content = JSON.stringify(exportData, null, 2);
    const hash = this.computeHash(content);

    return {
      format: ExportFormat.JSON,
      content,
      contentType: 'application/json',
      fileName: `konzernanhang_${document.fiscalYear}_v${document.version}.json`,
      fileSize: Buffer.byteLength(content, 'utf8'),
      contentHash: hash,
    };
  }

  /**
   * Export as plain text
   */
  private exportAsText(
    document: KonzernanhangDocument, 
    sections: KonzernanhangSection[],
  ): ExportResult {
    let text = '';
    
    // Header
    text += '═══════════════════════════════════════════════════════════════════\n';
    text += `                        KONZERNANHANG\n`;
    text += '═══════════════════════════════════════════════════════════════════\n\n';
    text += `Geschäftsjahr: ${document.fiscalYear}\n`;
    text += `Berichtszeitraum: ${this.formatDate(document.periodStart)} bis ${this.formatDate(document.periodEnd)}\n`;
    text += `Version: ${document.version}\n`;
    text += `Status: ${this.getStatusLabel(document.status)}\n`;
    text += `Erstellt: ${this.formatDateTime(document.generatedAt)}\n`;
    if (document.reviewedAt) {
      text += `Geprüft: ${this.formatDateTime(document.reviewedAt)} durch ${document.reviewedByName}\n`;
    }
    if (document.approvedAt) {
      text += `Freigegeben: ${this.formatDateTime(document.approvedAt)} durch ${document.approvedByName}\n`;
    }
    text += '\n═══════════════════════════════════════════════════════════════════\n\n';

    // Sections
    for (const section of sections) {
      text += `${section.sectionNumber}. ${section.sectionTitle.toUpperCase()}\n`;
      text += '───────────────────────────────────────────────────────────────────\n';
      if (section.hgbSection) {
        text += `[${section.hgbSection}]\n\n`;
      }
      if (section.contentText) {
        text += section.contentText + '\n';
      }
      text += '\n';
    }

    // Footer
    text += '═══════════════════════════════════════════════════════════════════\n';
    text += 'HGB-REFERENZEN\n';
    text += '───────────────────────────────────────────────────────────────────\n';
    for (const ref of this.getHgbReferences()) {
      text += `• ${ref}\n`;
    }
    text += '\n═══════════════════════════════════════════════════════════════════\n';
    text += `Exportiert am: ${this.formatDateTime(new Date())}\n`;

    const hash = this.computeHash(text);

    return {
      format: ExportFormat.TEXT,
      content: text,
      contentType: 'text/plain; charset=utf-8',
      fileName: `konzernanhang_${document.fiscalYear}_v${document.version}.txt`,
      fileSize: Buffer.byteLength(text, 'utf8'),
      contentHash: hash,
    };
  }

  /**
   * Export as Markdown
   */
  private exportAsMarkdown(
    document: KonzernanhangDocument, 
    sections: KonzernanhangSection[],
  ): ExportResult {
    let md = '';

    // Header
    md += `# Konzernanhang ${document.fiscalYear}\n\n`;
    md += `| Eigenschaft | Wert |\n`;
    md += `|-------------|------|\n`;
    md += `| Geschäftsjahr | ${document.fiscalYear} |\n`;
    md += `| Berichtszeitraum | ${this.formatDate(document.periodStart)} - ${this.formatDate(document.periodEnd)} |\n`;
    md += `| Version | ${document.version} |\n`;
    md += `| Status | ${this.getStatusLabel(document.status)} |\n`;
    md += '\n---\n\n';

    // Table of Contents
    md += '## Inhaltsverzeichnis\n\n';
    for (const section of sections) {
      md += `- [${section.sectionNumber}. ${section.sectionTitle}](#${this.slugify(section.sectionTitle)})\n`;
    }
    md += '\n---\n\n';

    // Sections
    for (const section of sections) {
      md += `## ${section.sectionNumber}. ${section.sectionTitle}\n\n`;
      if (section.hgbSection) {
        md += `*${section.hgbSection}*\n\n`;
      }
      if (section.contentText) {
        md += section.contentText + '\n\n';
      }
      if (section.contentJson && typeof section.contentJson === 'object') {
        // Try to render tables from JSON data
        const tableData = this.jsonToMarkdownTable(section.contentJson);
        if (tableData) {
          md += tableData + '\n\n';
        }
      }
      md += '---\n\n';
    }

    // HGB References
    md += '## HGB-Referenzen\n\n';
    for (const ref of this.getHgbReferences()) {
      md += `- ${ref}\n`;
    }
    md += '\n---\n\n';
    md += `*Exportiert am ${this.formatDateTime(new Date())}*\n`;

    const hash = this.computeHash(md);

    return {
      format: ExportFormat.MARKDOWN,
      content: md,
      contentType: 'text/markdown; charset=utf-8',
      fileName: `konzernanhang_${document.fiscalYear}_v${document.version}.md`,
      fileSize: Buffer.byteLength(md, 'utf8'),
      contentHash: hash,
    };
  }

  /**
   * Export as HTML
   */
  private exportAsHtml(
    document: KonzernanhangDocument, 
    sections: KonzernanhangSection[],
  ): ExportResult {
    let html = `<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Konzernanhang ${document.fiscalYear}</title>
  <style>
    :root {
      --primary: #1e3a5f;
      --secondary: #3d5a80;
      --accent: #ee6c4d;
      --bg: #f8f9fa;
      --text: #293241;
      --border: #dee2e6;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: var(--text);
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
      background: var(--bg);
    }
    .document-header {
      background: var(--primary);
      color: white;
      padding: 30px;
      border-radius: 8px;
      margin-bottom: 30px;
    }
    .document-header h1 {
      margin: 0 0 15px 0;
      font-size: 2em;
    }
    .meta-table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }
    .meta-table td {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .meta-table td:first-child {
      font-weight: 600;
      width: 180px;
    }
    .section {
      background: white;
      padding: 25px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .section h2 {
      color: var(--primary);
      margin-top: 0;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--accent);
    }
    .hgb-ref {
      display: inline-block;
      background: var(--secondary);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.85em;
      margin-bottom: 15px;
    }
    .section-content {
      white-space: pre-line;
    }
    table.data-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    table.data-table th,
    table.data-table td {
      padding: 10px 12px;
      border: 1px solid var(--border);
      text-align: left;
    }
    table.data-table th {
      background: var(--secondary);
      color: white;
    }
    table.data-table tr:nth-child(even) {
      background: #f8f9fa;
    }
    .footer {
      text-align: center;
      padding: 30px;
      color: #666;
      font-size: 0.9em;
    }
    .hgb-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      list-style: none;
      padding: 0;
    }
    .hgb-list li {
      background: #e9ecef;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 0.9em;
    }
    @media print {
      body { background: white; padding: 0; }
      .section { box-shadow: none; page-break-inside: avoid; }
      .document-header { background: #333 !important; -webkit-print-color-adjust: exact; }
    }
  </style>
</head>
<body>
  <div class="document-header">
    <h1>Konzernanhang</h1>
    <table class="meta-table">
      <tr><td>Geschäftsjahr</td><td>${document.fiscalYear}</td></tr>
      <tr><td>Berichtszeitraum</td><td>${this.formatDate(document.periodStart)} - ${this.formatDate(document.periodEnd)}</td></tr>
      <tr><td>Version</td><td>${document.version}</td></tr>
      <tr><td>Status</td><td>${this.getStatusLabel(document.status)}</td></tr>
      <tr><td>Erstellt am</td><td>${this.formatDateTime(document.generatedAt)}</td></tr>
      ${document.reviewedAt ? `<tr><td>Geprüft</td><td>${this.formatDateTime(document.reviewedAt)} (${document.reviewedByName})</td></tr>` : ''}
      ${document.approvedAt ? `<tr><td>Freigegeben</td><td>${this.formatDateTime(document.approvedAt)} (${document.approvedByName})</td></tr>` : ''}
    </table>
  </div>
`;

    // Sections
    for (const section of sections) {
      html += `
  <div class="section">
    <h2>${section.sectionNumber}. ${section.sectionTitle}</h2>
    ${section.hgbSection ? `<span class="hgb-ref">${section.hgbSection}</span>` : ''}
    ${section.contentHtml ? section.contentHtml : `<div class="section-content">${this.escapeHtml(section.contentText || '')}</div>`}
  </div>
`;
    }

    // Footer
    html += `
  <div class="section">
    <h2>HGB-Referenzen</h2>
    <ul class="hgb-list">
      ${this.getHgbReferences().map(ref => `<li>${ref}</li>`).join('\n      ')}
    </ul>
  </div>

  <div class="footer">
    Exportiert am ${this.formatDateTime(new Date())}
  </div>
</body>
</html>`;

    const hash = this.computeHash(html);

    return {
      format: ExportFormat.HTML,
      content: html,
      contentType: 'text/html; charset=utf-8',
      fileName: `konzernanhang_${document.fiscalYear}_v${document.version}.html`,
      fileSize: Buffer.byteLength(html, 'utf8'),
      contentHash: hash,
    };
  }

  /**
   * Record export in database
   */
  private async recordExport(
    documentId: string,
    result: ExportResult,
    options?: {
      exportedByUserId?: string;
      exportedByName?: string;
      exportPurpose?: string;
      recipient?: string;
    },
  ): Promise<void> {
    const { error } = await this.supabase
      .from('konzernanhang_exports')
      .insert({
        document_id: documentId,
        export_format: result.format,
        file_name: result.fileName,
        file_size: result.fileSize,
        content_hash: result.contentHash,
        exported_by_user_id: options?.exportedByUserId,
        exported_by_name: options?.exportedByName,
        exported_at: SupabaseMapper.getCurrentTimestamp(),
        export_purpose: options?.exportPurpose,
        recipient: options?.recipient,
        created_at: SupabaseMapper.getCurrentTimestamp(),
      });

    if (error) {
      console.error('Error recording export:', error);
      // Don't throw - recording is secondary to actual export
    }
  }

  /**
   * Get export history for a document
   */
  async getExportHistory(documentId: string): Promise<ExportMetadata[]> {
    const { data, error } = await this.supabase
      .from('konzernanhang_exports')
      .select('*')
      .eq('document_id', documentId)
      .order('exported_at', { ascending: false });

    if (error) {
      SupabaseErrorHandler.handle(error, 'Export History', 'fetch');
    }

    return (data || []).map((e: any) => ({
      id: e.id,
      documentId: e.document_id,
      format: e.export_format,
      fileName: e.file_name,
      fileSize: e.file_size,
      contentHash: e.content_hash,
      exportedByUserId: e.exported_by_user_id,
      exportedByName: e.exported_by_name,
      exportedAt: new Date(e.exported_at),
      exportPurpose: e.export_purpose,
      recipient: e.recipient,
    }));
  }

  // ==========================================
  // HELPER METHODS
  // ==========================================

  private getHgbReferences(): string[] {
    return [
      'HGB § 290 - Pflicht zur Aufstellung',
      'HGB § 291 - Befreiende Konzernabschlüsse',
      'HGB § 296 - Einbeziehungswahlrechte',
      'HGB § 301 - Kapitalkonsolidierung',
      'HGB § 303 - Schuldenkonsolidierung',
      'HGB § 304 - Zwischenergebniseliminierung',
      'HGB § 305 - Aufwands- und Ertragskonsolidierung',
      'HGB § 306 - Latente Steuern',
      'HGB § 307 - Anteile anderer Gesellschafter',
      'HGB § 308 - Einheitliche Bewertung',
      'HGB § 308a - Währungsumrechnung',
      'HGB § 309 - Behandlung des Unterschiedsbetrags',
      'HGB § 313 - Erläuterung der Konzernbilanz und GuV',
      'HGB § 314 - Sonstige Pflichtangaben',
    ];
  }

  private formatDate(date: Date): string {
    return date.toLocaleDateString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  }

  private formatDateTime(date: Date): string {
    return date.toLocaleString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  }

  private getStatusLabel(status: string): string {
    const labels: Record<string, string> = {
      draft: 'Entwurf',
      review_pending: 'Prüfung ausstehend',
      reviewed: 'Geprüft',
      finalized: 'Freigegeben',
      superseded: 'Ersetzt',
    };
    return labels[status] || status;
  }

  private computeHash(content: string): string {
    return crypto.createHash('sha256').update(content).digest('hex');
  }

  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[äöüß]/g, (match) => {
        const map: Record<string, string> = { ä: 'ae', ö: 'oe', ü: 'ue', ß: 'ss' };
        return map[match] || match;
      })
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-');
  }

  private jsonToMarkdownTable(data: any): string | null {
    // Handle arrays of objects
    if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
      const headers = Object.keys(data[0]);
      let table = '| ' + headers.join(' | ') + ' |\n';
      table += '| ' + headers.map(() => '---').join(' | ') + ' |\n';
      for (const row of data) {
        table += '| ' + headers.map(h => String(row[h] ?? '')).join(' | ') + ' |\n';
      }
      return table;
    }
    return null;
  }
}
